<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>uuid45 WASM Demo</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 1rem; }
    input[type=text] { width: 480px; max-width: 100%; }
    code { background: #f4f4f4; padding: 2px 4px; }
    .row { margin: 0.5rem 0; }
  </style>
</head>
<body>
  <h1>uuid45 WASM Demo</h1>
  <p>Generate UUID v4, encode to Base45 compact string, and decode back.</p>

  <div class="row">
    <button id="btn-gen">Generate v4</button>
    <span id="uuid"></span>
  </div>

  <div class="row">
    <label>UUID input: <input type="text" id="uuid-in" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"></label>
    <button id="btn-enc">Encode</button>
  </div>
  <div class="row">
    <label>Base45: <code id="b45"></code></label>
    <button id="btn-qr" style="margin-left:8px; display:none;">Generate a QR</button>
  </div>
  <div class="row" id="qr-config" style="display:none;">
    <label>URL prefix: <input type="text" id="qr-prefix" placeholder="https://example.com/data/" style="width:480px; max-width:100%"></label>
    <button id="btn-qr-confirm">Confirm</button>
  </div>
  <div class="row" id="qr-options" style="display:none;"></div>
  <div class="row" id="qr-view"></div>

  <div class="row">
    <label>Base45 input: <input type="text" id="b45-in" placeholder="Base45 string"></label>
    <button id="btn-dec">Decode</button>
  </div>
  <div class="row">
    <label>Decoded UUID: <code id="uuid-out"></code></label>
  </div>

  <script type="module">
    import init, { wasm_gen_v4, wasm_encode_uuid_str, wasm_decode_to_uuid_str } from './pkg/uuid45.js';

    // Minimal QR renderer using qrcode-generator (inline ESM loader)
    // We will dynamically import a small QR lib from CDN to keep this example simple.
    async function loadQRLIB() {
      if (window.qrcode) return window.qrcode; // function qrcode(typeNumber, errorCorrectLevel)
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js';
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('Failed to load qrcode-generator'));
        document.head.appendChild(s);
      });
      return window.qrcode;
    }

    // Utility: estimate alphanumeric length -> QR alphanumeric capacity planning
    function isBase45Char(ch) {
      const alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';
      return alphabet.indexOf(ch) >= 0;
    }

    function normalizeBase45PrefixInput(s) {
      // Uppercase and validate all chars are in Base45 alphabet (same as QR alphanumeric)
      const t = s.toUpperCase();
      for (const ch of t) {
        if (!isBase45Char(ch)) return { ok: false, val: t };
      }
      return { ok: true, val: t };
    }

    function estimateAlnumLen(str) {
      // Alphanumeric mode encodes the characters from the defined set; we just use length
      return str.length;
    }

    const QR_EC = { L: 1, M: 0, Q: 3, H: 2 }; // library uses: 0=M,1=L,2=H,3=Q

    function minimalVersionFor(len, ecLevel) {
      // QR capacities for ALPHANUMERIC mode per version (v1..v40)
      const cap = {
        L: [25,47,77,114,154,195,224,279,335,395,468,535,619,667,758,854,938,1046,1153,1249,1352,1460,1588,1704,1853,1990,2132,2223,2369,2520,2677,2840,3009,3183,3351,3537,3729,3927,4087,4296],
        M: [20,38,61,90,122,154,178,221,262,311,366,419,483,528,600,656,734,816,909,970,1035,1134,1248,1326,1451,1542,1637,1732,1839,1994,2113,2238,2369,2506,2632,2780,2894,3054,3220,3391],
        Q: [16,29,47,67,87,108,125,157,189,221,259,296,352,376,426,470,531,574,644,702,742,823,890,963,1041,1094,1172,1263,1322,1429,1499,1618,1700,1787,1867,1966,2071,2181,2298,2420],
        H: [10,20,35,50,64,84,93,122,143,174,200,227,259,283,321,365,408,452,493,557,587,640,672,744,779,864,910,958,1016,1080,1150,1226,1307,1394,1431,1530,1591,1658,1774,1852]
      };
      const arr = cap[ecLevel];
      for (let i = 0; i < arr.length; i++) {
        if (len <= arr[i]) return i + 1; // version index starts at 1
      }
      return null; // exceeds version 40
    }

    async function main() {
      await init();
      const uuidSpan = document.getElementById('uuid');
      const b45Span = document.getElementById('b45');
      const uuidOut = document.getElementById('uuid-out');
      const uuidIn = document.getElementById('uuid-in');
      const b45In = document.getElementById('b45-in');

      document.getElementById('btn-gen').addEventListener('click', () => {
        const u = wasm_gen_v4();
        uuidSpan.textContent = u;
        (uuidIn).value = u;
      });

      document.getElementById('btn-enc').addEventListener('click', async () => {
        try {
          const s = await wasm_encode_uuid_str(uuidIn.value.trim());
          b45Span.textContent = s;
          // Show QR button now that we have Base45
          document.getElementById('btn-qr').style.display = 'inline-block';
        } catch (e) {
          alert('Encode error: ' + e);
        }
      });

      document.getElementById('btn-dec').addEventListener('click', async () => {
        try {
          const s = await wasm_decode_to_uuid_str(b45In.value.trim());
          uuidOut.textContent = s;
        } catch (e) {
          alert('Decode error: ' + e);
        }
      });
    }

    document.getElementById('btn-qr').addEventListener('click', () => {
      document.getElementById('qr-config').style.display = 'block';
      document.getElementById('qr-options').style.display = 'none';
      document.getElementById('qr-view').innerHTML = '';
    });

    document.getElementById('btn-qr-confirm').addEventListener('click', async () => {
      const prefixRaw = (document.getElementById('qr-prefix')).value || '';
      const norm = normalizeBase45PrefixInput(prefixRaw);
      if (!norm.ok) { alert('Prefix contains characters outside Base45 alphabet. It has been uppercased: ' + norm.val); return; }
      const prefix = norm.val;
      const b45 = document.getElementById('b45').textContent.trim().toUpperCase();
      // Validate base45 payload characters
      for (const ch of b45) { if (!isBase45Char(ch)) { alert('Base45 content contains invalid characters.'); return; } }
      const payload = prefix + b45;
      const numericLen = estimateAlnumLen(payload);
      const ecLevels = ['L','M','Q','H'];
      const opts = [];
      for (const ec of ecLevels) {
        const ver = minimalVersionFor(numericLen, ec);
        if (ver) opts.push({ ec, ver });
      }
      const container = document.getElementById('qr-options');
      container.innerHTML = '';
      if (opts.length === 0) {
        container.textContent = 'Payload too large for versions up to 25 in numeric mode table.';
        container.style.display = 'block';
        return;
      }
      for (const {ec, ver} of opts) {
        const btn = document.createElement('button');
        btn.textContent = `v${ver} ${ec}`;
        btn.addEventListener('click', async () => {
          const lib = await loadQRLIB();
          // Using kazuhikoarase lib: qrcode(string, options)
          // Weâ€™ll let it auto-choose mode; for numeric mode only payload must be numeric.
          const typeNumber = ver; // 1..40
          const errorCorrectLevel = QR_EC[ec];
          const qr = new lib.QRCode(typeNumber, errorCorrectLevel);
          qr.addData(payload);
          qr.make();
          const svg = qr.createSvgTag(6, 0);
          const view = document.getElementById('qr-view');
          view.innerHTML = svg;
        });
        container.appendChild(btn);
      }
      container.style.display = 'block';
    });

    main();
  </script>
</body>
</html>
